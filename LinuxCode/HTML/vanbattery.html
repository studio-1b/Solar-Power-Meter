<html>
<head>
    <title>Van Battery Power</title>
    <link rel="stylesheet" type="text/css" href="Chart.min.css">
	<script src="Chart.min.js"></script>
	<style>
		div.pane {
			width:100%;
			height:40%;
		}
		div.page {
			width:100%;
			height:90%;
		}
		td div.horizontalchart {
			width:100%;
			height:100%;
		}
		table.infobox tr td 
		{
		    font-size:10pt;
		}
	</style>
</head>
<body>
    <div class="content">
		<h1>Van Power Status <span id="loaddatetime">Sun 12/15/2019, 14:10:23</span></h1>
		<h2>Bottom line</h2>
		<table width="100%" class="infobox">
			<tr valign="top">
				<td colspan="2">
                    <u>Battery Amps</u>
				</td>
				<td colspan="2">
                    <u>Circuit Volts</u>
				</td>
                <td rowspan="6">
                    <div class="horizontalchart">
			            <canvas id="chart-horizontal"></canvas>
		            </div>
                </td>
			</tr>
            <tr>
                <td nowrap>Delta 24hrs ago:</td>
                <td nowrap><span id="ma24">0</span> mA</td>
                <td nowrap>Voltage yesterday:</td>
                <td nowrap><span id="mv24">0</span>mV</td>
            </tr>
            <tr>
                <td nowrap>Graph battery net:</td>
                <td nowrap><span id="mah24">0</span> mAh</td>
                <td nowrap>Change Voltage 24 hours:</td>
                <td nowrap><span id="dmv24">0</span>mV</td>
            </tr>
            <tr>
                <td nowrap>Daily Ah (avg mA*24):</td>
                <td nowrap><span id="mahdaily">0</span> mAh</td>
                <td nowrap>Daily range:</td>
                <td nowrap><span id="mvlow">0</span> to <span id="mvhigh">0</span> mV</td>
            </tr>
		</table>
		
		<br/>
		<h2>Last 24 hours</h2>
		<div class="pane">
			<canvas id="chart-1"></canvas>
		</div>
		<div class="pane">
			<canvas id="chart-2"></canvas>
		</div>
		<h2>Historical Solar Daily Output</h2>
		<!--Stacked bar chart / stacked area chart
		Different dataset for each Month
		column(x) for for each hour-->
		<div class="page">
			<canvas id="chart-3"></canvas>
		</div>

		<h2>Daily Battery Net Ah for last 365 days</h2>
		Solar and Battery and State of Charge 
		<div class="pane">
			<canvas id="chart-4"></canvas>
		</div>

		<h2>RTC vs GPS NTP performance</h2>
		<div class="page">
			<canvas id="chart-5"></canvas>
		</div>

		<h2>Battery amperage vs Circuit Voltage drop</h2>
		<div class="page">
			<canvas id="chart-6"></canvas>
		</div>
		
		<h2>Delta mV change vs Daily Battery Avg mA </h2>
		Theoretically, zero mV change in state of charge of the battery, should be a net zero mA in and out of battery.  So we should be able to determine if the ammeter is miscalibrated.
		<div class="page">
			<canvas id="chart-7"></canvas>
		</div>

		<h2>Battery mA charge vs Solar mA input </h2>
		Create a calibration model against solar amp sensor as standard.
		<div class="page">
			<canvas id="chart-8"></canvas>
		</div>
	</div>

	<script>
		window.chartColors = {
			white: 'rgb(255, 255, 255)',
			black: 'rgb(0, 0, 0)',
			red: 'rgb(255, 99, 132)',
			orange: 'rgb(255, 159, 64)',
			yellow: 'rgb(255, 205, 86)',
			green: 'rgb(75, 192, 192)',
			blue: 'rgb(54, 162, 235)',
			purple: 'rgb(153, 102, 255)',
			grey: 'rgb(201, 203, 207)',
			aqua: 'rgb(0, 255, 255)',
			teal: 'rgb(0, 128, 128)',
			maroon: 'rgb(128, 0, 0)',
			olive: 'rgb(128, 128, 0)',
			lime: 'rgb(0, 255, 0)',
			fushia: 'rgb(128, 0, 128)',
			navy: 'rgb(0, 0, 128)',
			pink: 'rgb(255, 192, 203)',
			saddlebrown: 'rgb(139, 69, 19)'
		};
		var presets = window.chartColors;

		function transparentize(color, opacity) {
			var alpha = opacity === undefined ? 0.5 : 1 - opacity;
			return window.Color(color).alpha(alpha).rgbString();
		}

        var horizontaldata = {
			labels: ["milliamps","milliamps","millivolts","millivolts"],
			datasets: [{
				backgroundColor: transparentize(presets.blue),
				borderColor: presets.blue,
				data: [0,0,0,0],
				label: 'Battery'
			}, {
				backgroundColor: transparentize(presets.yellow),
				borderColor: presets.yellow,
				data: [0,0,0,0],
				label: 'Solar'
			}]
		};

		var sample = 0; 
		function generateData() {
			sample++;
			return [ 62.3/sample, 35.58/sample, 33.98/sample, 71.57, 26.88, 29.54/sample, 46.95/sample, 50.97/sample ];
		}

		function generateLabels() {
			return [ "January", "February", "March", "April", "May", "June", "July", "August" ];
		}
		var barChartData = {
			labels: ['60','59','58','57','56','55','54','53','52','51','50','49','48','47','46','45','44','43','42','41','40','39','38','37','36','35','34','33','32','31','30','29','28','27','26','25','24','23','22','21','20','19','18','17','16','15','14','13','12','11','10','9','8','7','6','5','4','3','2','1','0','Amps', 'Volts'],
			datasets: [{
				type:'line',
				label: 'Battery Amp Graph',
				backgroundColor: window.Color(window.chartColors.red).alpha(0.5).rgbString(),
				borderColor: window.chartColors.red,
				borderWidth: 1,
				fill:'origin',
				data: [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
					null,
					null
				]
			}, {
				type:'line',
				label: 'Battery Volt Graph',
				borderColor: window.chartColors.red,
				borderWidth: 2,
				fill:false,
				data: [12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12100,12095,12090,12080,12070,12050,12000,11990,11950,11900,11860,11840,11820,11800,12100,11790,11780,
					null,
					null
				]
			}, {
				type:'bar',
				label: 'Battery Now',
				backgroundColor: window.Color(window.chartColors.red).alpha(0.5).rgbString(),
				borderColor: window.chartColors.red,
				borderWidth: 1,
				data: [0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,0100,-200,-300,-400,-500,-700,-1000,-1100,
					-500,
					11780
				]
			}, {
				type:'bar',
				label: 'Solar Now',
				backgroundColor: window.Color(window.chartColors.yellow).alpha(0.5).rgbString(),
				borderColor: window.chartColors.yellow,
				borderWidth: 1,
				data: [null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,
					700,
					12100
				]
			}]

		};
		function generate24(start) {
			return Array.from(new Array(24), (x,i) => (start+i+1)%24);
		}
		function generateAmps(start,baseline) {
			var curve = [-1.200,-1.200,-1.200,-1.200,-1.200,-1.200,-1.200,-1.000,-0.500,-0.100,1.100,3.300,7.100,7.100,7.100,6.500,5.800,2.200,1.100,-0.600,-1.200,-1.200,-1.200,-1.200];
			var h = generate24(start);
			return  Array.from(h, (x,i) => curve[x]+baseline);
		}
		function generateVolts(start,m,b) {
			var curve = [12.400,12.390,12.380,12.370,12.360,12.350,12.340,12.330,12.325,12.325,12.600,13.600,14.000,14.100,14.100,14.000,13.800,13.400,12.9,12.500,12.490,12.470,12.430,12.410];
			var h = generate24(start);
			return  Array.from(h, (x,i) => m*curve[x]+b);
		}
		function generateSoc(start) {
			var curve = [80,79,78,77,76,75,74,73,72,71,71,72,75,78,82,86,89,90,91,90,89,86,83,81];
			var h = generate24(start);
			return  Array.from(h, (x,i) => curve[x]);
		}
		var ampdata = {
			labels: generate24(23),
			datasets: [{
				backgroundColor: window.Color(window.chartColors.blue).alpha(0.4).rgbString(), //transparentize(presets.blue),
				borderColor: presets.blue,
				data: generateAmps(23,0),
				label: 'Battery mA (Last 24 hr)',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.yellow),
				borderColor: presets.yellow,
				data: generateAmps(23,1.200),
				label: 'Solar mA (Last 24 hr)',
				fill: 'origin'
			}, {
				type:'bar',
				backgroundColor: window.Color(window.chartColors.black).alpha(0.1).rgbString(),
				borderColor: presets.black,
				width:'100%',
				barPercentage:1.25,
				data: generateAmps(23,-0.300),
				label: 'Avg(mA) for hour',
				fill: '-1'
			}, {
				backgroundColor: window.Color(window.chartColors.blue).alpha(0.3).rgbString(), //transparentize(presets.blue),
				borderColor: presets.blue,
				data: generateAmps(23,0),
				label: 'Calibrated Battery mA',
				hidden: true,
				fill: 'origin'
			}]
		};
		var voltagedata = {
			labels: generate24(23),
			datasets: [{
				type:'line',
				backgroundColor: transparentize(presets.blue),
				borderColor: presets.blue,
				data: generateVolts(23,1,0),
				label: 'Battery mV (Last 24 hr)',
				yAxisID: 'y-axis-1',
				fill: false
			}, {
				type:'line',
				backgroundColor: transparentize(presets.yellow),
				borderColor: presets.yellow,
				data: generateVolts(23,2.0,-12.5),
				label: 'Solar mV (Last 24 hr)',
				yAxisID: 'y-axis-1',
				hidden: true,
				fill: false
			}, {
				type:'bar',
				backgroundColor: transparentize(presets.lime),
				borderColor: presets.lime,
				data: generateSoc(23),
				label: 'Est Battery (mAh)',
				yAxisID: 'y-axis-2',
				hidden: true,
				fill: 1
            }, {
				type:'line',
				backgroundColor: transparentize(presets.green),
				borderColor: presets.green,
				data: generateSoc(23),
				label: 'Max Battery (mAh)',
				yAxisID: 'y-axis-2',
				hidden: true,
				fill: false
			}]
		};
		var summarydata = {
			labels: generate24(23),
			datasets: [{
				type:'bar',
				backgroundColor: transparentize(presets.black),
				borderColor: presets.black,
				data: generateAmps(23,-2.0/12),
				label: 'Avg Battery Net(mAh)',
				yAxisID: 'y-axis-2',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.navy),
				borderColor: presets.navy,
				data: generateAmps(23,-2.0/12),
				label: 'Jan',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.pink),
				borderColor: presets.pink,
				data: generateAmps(23,-1.5/24),
				label: 'Feb',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.lime),
				borderColor: presets.lime,
				data: generateAmps(23,-0.9/12),
				label: 'Mar',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.yellow),
				borderColor: presets.yellow,
				data: generateAmps(23,-0.5/12),
				label: 'Apr',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.red),
				borderColor: presets.red,
				data: generateAmps(23,-0.1/12),
				label: 'May',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.fushia),
				borderColor: presets.fushia,
				data: generateAmps(23,1.0/12),
				label: 'Jun',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.maroon),
				borderColor: presets.maroon,
				data: generateAmps(23,2.0/12),
				label: 'Jul',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.olive),
				borderColor: presets.olive,
				data: generateAmps(23,1.5/12),
				label: 'Aug',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.grey),
				borderColor: presets.grey,
				data: generateAmps(23,0.5/12),
				label: 'Sep',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.orange),
				borderColor: presets.orange,
				data: generateAmps(23,-0.5/12),
				label: 'Oct',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.saddlebrown),
				borderColor: presets.saddlebrown,
				data: generateAmps(23,-1.5/12),
				label: 'Nov',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}, {
				backgroundColor: transparentize(presets.green),
				borderColor: presets.blue,
				data: generateAmps(23,-2/12),
				label: 'Dec',
				yAxisID: 'y-axis-1',
				fill: 'origin'
			}]
		};
		var annualAmpData = {
			labels: ['Date1', 'Date2'],
			datasets: [{
				type:'line',
				label: 'Battery Daily net (aH)',
				backgroundColor: window.Color(window.chartColors.blue).alpha(0.5).rgbString(),
				borderColor: window.chartColors.blue,
				borderWidth: 1,
				fill:'origin',
				data: [0,0]
			}, {
				type:'line',
				label: 'Solar Daily output (aH)',
				backgroundColor: window.Color(window.chartColors.yellow).alpha(0.5).rgbString(),
				borderColor: window.chartColors.yellow,
				borderWidth: 1,
				fill:'origin',
				data: [0,0]
			}, {
				type:'line',
				label: 'Calibrated Batt net (aH)',
				backgroundColor: window.Color(window.chartColors.blue).alpha(0.4).rgbString(),
				borderColor: window.chartColors.blue,
				borderWidth: 1,
				fill:'origin',
				hidden: true,
				data: [0,0]
			}]

		};

		var options = {
			maintainAspectRatio: false,
			spanGaps: false,
			elements: {
				line: {
					tension: 0.4
				}
			},
			scales: {
				yAxes: [{
                    position: 'right',
					stacked: false
				}]
			}
		};
		var option2axes = {
			maintainAspectRatio: false,
			spanGaps: false,
			elements: {
				line: {
					tension: 0.4
				}
			},
			scales: {
				yAxes: [{
					type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
					display: true,
					position: 'right',
					id: 'y-axis-1',
				}, {
					type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
					display: true,
					position: 'left',
					id: 'y-axis-2',
                    ticks: {
                        beginAtZero: true
                    },
					gridLines: {
						drawOnChartArea: false
					}
				}]
			}
		};
		var optionstacked = {
			maintainAspectRatio: false,
			spanGaps: false,
			elements: {
				line: {
					tension: 0.4
				}
			},
			scales: {
				yAxes: [{
					stacked: true
				}]
			}
		};
		var option2axesstacked = {
			maintainAspectRatio: false,
			spanGaps: false,
			elements: {
				line: {
					tension: 0.4
				}
			},
			scales: {
				yAxes: [{
					type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
					display: true,
					position: 'right',
					id: 'y-axis-1',
					stacked: true
				}, {
					type: 'linear', // only linear but allow scale type registration. This allows extensions to exist solely for log scale for instance
					display: true,
					position: 'left',
					id: 'y-axis-2',
                    ticks: {
                        beginAtZero: true
                    },
					gridLines: {
						drawOnChartArea: false
					}
				}]
			}
		};
		var optionslabelmAhVsDv = {
			maintainAspectRatio: false,
			spanGaps: false,
			elements: {
				line: {
					tension: 0.4
				}
			},
			scales: {
				yAxes: [{
                    position: 'left',
					stacked: false,
					scaleLabel: {
						display:true,
						labelString:'Voltage drop (mV)'
					}
				}],
				xAxes: [{
					scaleLabel: {
						display:true,
						labelString:'Battery discharge (-mAh)'
					}
				}]
			}
		};
        
        var gauge = new Chart('chart-horizontal', {
			type: 'horizontalBar',
			data: horizontaldata,
			options: options
		});
        var chart1 = new Chart('chart-1', {
			type: 'line',
			data: ampdata,
			options: options
		});
		var chart2 = new Chart('chart-2', {
			type: 'line',
			data: voltagedata,
			options: option2axes
		});
		var chart3 = new Chart('chart-3', {
			type: 'line',
			data: summarydata,
			options: option2axesstacked
		});
		var chart4 = new Chart('chart-4', {
			type: 'bar',
			data: annualAmpData,
			options: options
		});
		var chart5 = new Chart('chart-5', {
			type: 'scatter',
			data: {
				datasets: [{
					label: 'RTC elapsed vs NTP elapsed',
					borderColor: presets.red,
					backgroundColor: transparentize(presets.red),
					data: [{x:0, y:0},{x:1,y:1}]
				}, {
					label: 'least sqrs regression',
					borderColor: presets.blue,
					backgroundColor: transparentize(presets.blue),
					showLine:true,
					fill:false,
					data: [{x:0, y:1},{x:1,y:0}]
				}]
			},
			options: options
		});
		var chart6 = new Chart('chart-6', {
			type: 'scatter',
			data: {
				datasets: [{
					label: 'Battery mAh discharged vs voltage drop',
					borderColor: presets.navy,
					backgroundColor: transparentize(presets.navy),
					data: [{x:0, y:0},{x:1,y:1}]
				}, {
					label: 'least sqrs regression',
					borderColor: presets.lime,
					backgroundColor: transparentize(presets.lime),
					showLine:true,
					fill:false,
					data: [{x:0, y:1},{x:1,y:0}]
				}, {
					label: 'Battery mAh charged vs voltage increase',
					borderColor: presets.blue,
					backgroundColor: transparentize(presets.blue),
					data: [{x:0, y:0},{x:1,y:1}]
				}, {
					label: 'least sqrs regression',
					borderColor: presets.green,
					backgroundColor: transparentize(presets.green),
					showLine:true,
					fill:false,
					data: [{x:0, y:1},{x:1,y:0}]
				}]
			},
			options: optionslabelmAhVsDv
		});
		var chart7 = new Chart('chart-7', {
			type: 'scatter',
			data: {
				datasets: [{
					label: '(x) Daily voltage increase/drop vs Daily avg amp',
					borderColor: presets.lime,
					backgroundColor: transparentize(presets.lime),
					data: [{x:0, y:0},{x:1,y:1}]
				}, {
					label: 'least sqrs regression',
					borderColor: presets.olive,
					backgroundColor: transparentize(presets.olive),
					showLine:true,
					fill:false,
					data: [{x:0, y:1},{x:1,y:0}]
				}]
			},
			options: options
		});
		var chart8 = new Chart('chart-8', {
			type: 'scatter',
			data: {
				datasets: [{
					label: '(x) Battery mA vs Solar mA',
					borderColor: presets.lime,
					backgroundColor: transparentize(presets.lime),
					data: [{x:0, y:0},{x:1,y:1}]
				}, {
					label: 'least sqrs regression',
					borderColor: presets.olive,
					backgroundColor: transparentize(presets.olive),
					showLine:true,
					fill:false,
					data: [{x:0, y:1},{x:1,y:0}]
				}]
			},
			options: options
		});

		// eslint-disable-next-line no-unused-vars
		function toggleSmooth(btn) {
			var value = btn.classList.toggle('btn-on');
			chart.options.elements.line.tension = value ? 0.4 : 0.000001;
			chart.update();
		}
	</script>
	<script>
		function selectWhere(objarray, fieldname, castfn, where) {
			var count = 0;
			var len = objarray.length;
			var values = new Array();
			for (var i = 0; i < len; i++) {
				var record = objarray[i];
				if(record!=null)
				if (where==null || where(record)) {
					var text = record[fieldname];
					var value = castfn == null ? text : castfn(text);
					if (castfn == null || value!=undefined) {
						values[count] = value;
						count++;
					}
				}
			}
			return values;
        }
        function sortSelectWhere(objarray, compare, fieldname, castfn, where) {
            var count = 0;
            var len = objarray.length;
            if (compare != null)
                objarray.sort(compare);

            var values = new Array();
            for (var i = 0; i < len; i++) {
                var record = objarray[i];
                if (record != null)
                    if (where == null || where(record)) {
                        var text = record[fieldname];
                        var value = castfn == null ? text : castfn(text);
                        if (castfn == null || value!=undefined) {
                            values[count] = value;
                            count++;
                        }
                    }
                }
            return values;
        }
        function selectOne(objarray, where) {
            var count = 0;
            var len = objarray.length;
            for (var i = 0; i < len; i++) {
                var record = objarray[i];
                if (record != null)
                    if (where == null || where(record)) {
                        return record;
                    }
            }
            return value;
        }
		function leastsqrregression(listxy) {
			var sumx=0;
			var sumx2=0;
			var sumxy=0;
			var sumy=0;
			var sumy2=0;
			var n=0;
			var len = listxy.length;
			for(var i=0; i<len; i++) {
				var pt = listxy[i];
				if(pt!=null) {
					sumx+=pt.x;
					sumx2+=Math.pow(pt.x,2);
					sumxy+=pt.x*pt.y;
					sumy+=pt.y;
					sumy2+=Math.pow(pt.y,2);
					n++;
				}
			}

			var denom = n * sumx2 -Math.pow(sumx,2);
			if(denom==0)
				return null;
			
			var m = (n*sumxy - sumx*sumy)/denom;
			var multiple = Math.min(32000/m,32000);
			var mN = Math.round(m*multiple);
			var mD = Math.round(multiple);
			var intercept = (sumy*sumx2 - sumx*sumxy)/denom;
			return new ymxb(mN,mD,intercept,n); //line equation in algebra is y=mx+b
		}
		function xy(x,y) {
			this.x = x;
			this.y = y;
			//return { "x":x, "y":y };
		}
		function xyz(x,y,z) {
			this.x = x;
			this.y = y;
			this.z = z;
			//return { "x":x, "y":y };
		}
		function ymxb(mN,mD,b,n){
			this.mN = mN;
			this.mD = mD;
			this.b = b;
			this.n = n;
			this.y = function(x){
				return this.mN*x/this.mD + this.b;
			}
			this.f = function(x){
				return new xy(x, this.mN*x/this.mD + this.b);
			}
			this.inv = function(y){
				//y=mx+b, (y-b)/m = x
				return new xy((y- this.b)*this.mD/this.mN, y);
			}
			this.logString = function(){
				return "y=("+mN+"/"+mD+")x+"+b+"...n="+n;
			}
			//return this;
		}
        // https://www.phpied.com/3-ways-to-define-a-javascript-class/
        function SessionStatefulConverter() {
            this.prevDateTokens = null;

            this.toAbbrDateString = function (fullstring) {

                var tokens = fullstring.split(" ");
                if (this.prevDateTokens == null) {
                    this.prevDateTokens = tokens;
                    return tokens[0];
                }
                var len = Math.min(tokens.length, this.prevDateTokens.length);
                for (var i = 0; i < len; i++) {
                    if (this.prevDateTokens[i] != tokens[i]) {
                        this.prevDateTokens = tokens;
                        return tokens[i];
                    }
                }
                this.prevDateTokens = tokens;
                return "";
            }
        }
		function vertice(a,b) {
			this.a = a;
			this.b = b;
			this.d = Math.sqrt((a.x-b.x)*(a.x-b.x)+(a.y-b.y)*(a.y-b.y));
			//return { "x":x, "y":y };
		}
		function prims(listxy) {
			var vertices = new Array();
			var len = listxy.length;
			for(var i=0; i<len;i++)
				for(var j=0; j<len;j++)
					if(i!=j && listxy[i]!=null && listxy[j]!=null)
						vertices.push(new vertice(listxy[i],listxy[j]));
			vertices.sort(function(a,b){ return a.d-b.d; });
			len = vertices.length;
			//var copy = Array.from(listxy);
			var used = 0;
			var graph = new Array();
			for(var i=0; i<len; i++){
				var tested = vertices[i];
				var found = (graph.includes(tested.a)?1:0)+(graph.includes(tested.b)?1:0);
				if(found<2) {
					graph.push(tested);
					used+=(2-found);
					if(used>=listxy.length)
						break;
				}
			}
			return graph;
		}
		function stupidtraverse(graph){
			var listxy = new Array();
			var len = graph.length;
			for(var i=0; i<len; i++) {
				var edge = graph[i];
				if(listxy.find(element => element==edge.a)==null)
					listxy.push(edge.a);
				if(listxy.find(element => element==edge.b)==null)
					listxy.push(edge.b);
			}
			return listxy;
		}
		function minimizeStdev(listxy) {
			var fit = new Array();
			var stdev = new Array();
			var best = -1;
			var lowest = -1;
			var copy = Array.from(listxy);
			var len = listxy.length;
			for(var i=Math.round(len*0.67); i<len;i++){
				var line = fit[i] = leastsqrregression(copy);
				var err = stdev[i] = Math.sqrt(variancefrommodel(copy,line)); 
				if(err<lowest || best==-1){
					best = i;
					lowest = err;
					console.log("" +i+ "/"+len+". best stdev "+err+" is " + line.logString());
				} else
					console.warn("" +i+ "/"+len+". skipped stdev "+err+" is " + line.logString());
				copy.length--;
			}
			return fit[best];
		}
		function variancefrommodel(listxy,line){
			var variance = 0;
			var len = listxy.length;
			for(var i=0; i<len; i++) {
				var pt = listxy[i];
				if(pt!=null) {
					var predicted = line.y(pt.x);
					var actual = pt.y;
					var err = predicted-actual;
					variance += err*err;
				}
			}
			return variance/len;
		}
		//assumes valid datapoints are close to each other
		//(mis)uses prim's algorthm as a cluster algorithm, and assumes prims will return a list of points that are far away from each other
		function minlinearregression(listxy){
			var graph = prims(listxy);
			var reorderedxy = stupidtraverse(graph);
			var line = minimizeStdev(reorderedxy);
			return line;
		}
	</script>
	<script>
		var batteryzeroampcalibration = 0;
		var batteryampcalibration = 1;
		var batterysolarcalibration = new ymxb(1,1,0,144);
		function adjustForCalibration(ydata) {
            return Array.from(ydata, (v,i) => Math.round(batterysolarcalibration.y(v)) );
		}
		function displayCalibration() {
			var m = Math.round(10000 * batterysolarcalibration.mN/batterysolarcalibration.mD)/10000;
			chart1.data.datasets[3].label = "Calibrated Battery mA=" + m + "x+" + batterysolarcalibration.b;
		}

		function getXHR() {
			if (window.XMLHttpRequest) {
				return new XMLHttpRequest();
			} else {
				return new ActiveXObject('Microsoft.XMLHTTP');
			}
		}
		var cancellableXHR;
		function getCancellableXHR() {
			return cancellableXHR = getXHR();
		}
		var pollrunning = false;
		function pollForJsonUpdate(timerID, url, callback) {
			console.log("polled at " + (new Date()));			
			console.log("readystate " + cancellableXHR);
			if(cancellableXHR!=null) console.log("readystate" + cancellableXHR.readyState);

			if(!pollrunning) {
				pollrunning = true;

				var req = getCancellableXHR();
				if (!req) return false;

				req.onload = function () {
                    cancellableXHR = null;
                    pollrunning = false;
					try {
						var json = this.response;
						console.log("Returned " +json.length+ " bytes = " + json.substring(0,200) +"...");
						var deserialized = JSON.parse(json);
						callback(deserialized);
					} finally {
						pollrunning = false;
					}
				};
				req.onerror = function () {
					if(cancellableXHR!=null && cancellableXHR.readyState!=1 && cancellableXHR.readyState!=2 && cancellableXHR.readyState!=3) {
						console.error("cancelling poll " + timerID);
						clearInterval(timerID); //in case the connection dies, and the eventhandlers haven't fired.
					}

                    cancellableXHR = null;
					pollrunning = false;
				};

				//var tabs = document.getElementById("outputTabs");
				//var existing = tabs.childNodes.length-1;
				console.log("Sending GET request thru XHR :" + url);

				req.open('get', url, true);
				req.withCredentials = true;
				req.send(null);
			}
		}
		function processIntervalAvg(json) {
		    if (json == null || !Array.isArray(json))
			{
				console.error('processIntervalAvg.  Last polled json response had an error.  ' + json);
				return false;
			}
			
			//detect change
            json.sort(function (a, b) { if (a == b) return 0; if (a == null) return -1; if (b == null) return 1; var diff = Date.parse(a.timestamp) - Date.parse(b.timestamp); return diff < 0 ? -1 : diff > 0 ? 1 : 0 });

            //update ChartJs
            var converter = new SessionStatefulConverter();
            chart1.data.labels = selectWhere(json, "timestamp", converter.toAbbrDateString, null);
            chart1.data.x = selectWhere(json, "timestamp", Date.parse, null); //not documented, but added ad-hoc
			chart1.data.datasets[0].data = selectWhere(json, "battery_ma", null, null);
			var uncalibratedsolar = selectWhere(json, "solar_ma", null, null);
			var solarbaseline = uncalibratedsolar.reduce((a,b) => b==null ? a : a>b ? b : a, 0);
			var calibratedsolar = Array.from(uncalibratedsolar, (v,i)=>v-solarbaseline);
			chart1.data.uncalibratedsolar = uncalibratedsolar;
			chart1.data.datasets[1].label = "Solar mA (last 24 hr) -" +(solarbaseline) + "";
			chart1.data.datasets[1].data = calibratedsolar;
			//chart1.data.datasets[1].label = "Solar mA (last 24 hr)";
			//chart1.data.datasets[1].data = uncalibratedsolar;
			chart1.data.datasets[3].data = adjustForCalibration(selectWhere(json, "battery_ma", null, null));

			//hourly averages from another chart
			if(chart3.data.labels.length==24 && chart3.data.datasets[0].data.length==24) {
				var hours = chart3.data.labels;
				var avgmahonhour = chart3.data.datasets[0].data;
	
				var remap = new Array(24); //local back to utc hour
				for(var i=0; i<24;i++)
					remap[hours[i]] = i; //chart3.data.labels
				chart1.data.datasets[2].data = Array.from(chart1.data.x, (v,i) => isNaN(v) ? 0 : remap[(new Date(v)).getHours()]==null ? 0 : avgmahonhour[remap[(new Date(v)).getHours()]] );
			}
			chart1.update();

			chart2.data.labels = chart1.data.labels;
			chart2.data.datasets[0].data = selectWhere(json, "system_mv", null, null);
			chart2.data.datasets[1].data = selectWhere(json, "solar_mv", null, null);
			chart2.update();
            
            //update ChartJs
            var last = json[json.length-1];
            var first = json[1];
			var graphhours = (Date.parse(last.timestamp) - Date.parse(first.timestamp))/(60*60*1000);
            var graphavgamps = json.reduce((a,b) => b==null ? a : a + b.battery_ma, 0)/json.length;
			var totalmah = Math.round(graphhours*graphavgamps);
			//console.log(Date.parse(last.timestamp) - Date.parse(first.timestamp));
			//console.log(graphhours);
			//console.log(graphavgamps);
            document.getElementById("mah24").innerHTML = totalmah;
            document.getElementById("ma24").innerHTML = last.battery_ma - first.battery_ma;
            document.getElementById("dmv24").innerHTML = last.system_mv - first.system_mv;
            document.getElementById("mv24").innerHTML = first.system_mv ;
            var vmax = 0;
            var vmin = 50000;
            for(var i=1; i<json.length-1; i++) {
                vmax = Math.max(vmax, json[i].system_mv);
                vmin = Math.min(vmin, json[i].system_mv);
            }
            document.getElementById("mvlow").innerHTML = vmin;
            document.getElementById("mvhigh").innerHTML = vmax;

            gauge.data.labels[0] = last.battery_ma + " mA";
            gauge.data.labels[1] = last.solar_ma + " mA";
            gauge.data.labels[2] = last.system_mv + " mV";
            gauge.data.labels[3] = last.solar_mv + " mV";
            gauge.data.datasets[0].data[0] = last.battery_ma;
			gauge.data.datasets[1].data[1] = last.solar_ma;
            gauge.data.datasets[0].data[2] = last.system_mv;
            gauge.data.datasets[1].data[3] = last.solar_mv;
            gauge.update();

			document.getElementById("loaddatetime").innerHTML = chart1.data.labels[chart1.data.labels.length-1];

			analyzeBatteryHealth();
			processCalibrationSolarStd();
    	}
		function updateIntervalAvg() {
			pollForJsonUpdate(intervalAvgTimerID, "latestintervalavgs.json", processIntervalAvg);
        }
        var intervalAvgTimerID = setInterval(updateIntervalAvg, 60000); //every min, though it only update 1/min... only wait a min for latest update
        

        function toHour(text) {
            if (text == null)
                return -1;
            var datetime = Date.parse(text);
            if (isNaN(datetime))
                return -1;
            return (new Date(datetime)).getHours();
        }
        function processHourlyAh(json) {
            if (json == null || !Array.isArray(json)) {
                console.error('Last polled json response had an error.');
                return false;
            }

            //detect change

            //update ChartJs
			var overall = json[0];
			overall.length=24;
            var remap = new Array(24); //local back to utc hour
            for(var i=0; i<24;i++)
                if(overall[i]!=null)
                    remap[overall[i].hour_local] = overall[i].hour_utc;
			
			// the average net battery output added to amp graph, re-aligned for current time
			//console.log(remap);
            chart1.data.datasets[2].data = Array.from(chart1.data.x, (v,i) => isNaN(v) ? 0 : remap[(new Date(v)).getHours()]==null ? 0 : overall[remap[(new Date(v)).getHours()]].mah_avg );
            chart1.update();

			// the daily solar output for each month
			//display the 
            chart3.data.labels = Array.from(overall, (v,i) => overall[i]==null ? i+"UTC" : v.hour_local );
			chart3.data.datasets[0].data =   Array.from(json[0], (v,i) => v==null ? 0 : v.mah_avg );
            for(var m=1; m<=12;m++)
				chart3.data.datasets[m].data =   Array.from(json[m], (v,i) => v==null ? 0 : v.solar_mah_avg );
            //chart3.data.datasets[1].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[2].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[3].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[4].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[5].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[6].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[7].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[8].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[9].data =   Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[10].data =  Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[11].data =  Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			//chart3.data.datasets[12].data =  Array.from(remap, (v,i) => json[i]==null ? 0 : json[i].mah_avg );
			chart3.update();

            
			document.getElementById("mahdaily").innerHTML = Math.round(json.reduce((o,n)=>o==null ? n : n==null ? o : o+n.mah_total) / json.reduce((o,n)=> o==null ? n : n==null ? o : o+n.sample_count));
        }
        function updateHourlyAh() {
            pollForJsonUpdate(hourAvgTimerID, "houravg.json", processHourlyAh);
        }
        var hourAvgTimerID = setInterval(updateHourlyAh, 600000); //every 10min, though updated 1/hr, only wait 10min for latest update
        


        function processMeterInstant(json) {
            if (json == null || !Array.isArray(json)) {
                console.error('Last polled json response had an error.');
                return false;
            }

            //detect change
            json.sort(function (a, b) { if (a == b) return 0; if (a == null) return -1; if (b == null) return 1; var diff = Date.parse(a.timestamp) - Date.parse(b.timestamp); return diff < 0 ? -1 : diff > 0 ? 1 : 0 });


            //update ChartJs
            var closest = Array.from(chart1.data.x, (v,i) => json.reduce((o,n) => o==null ? n : Math.abs(v-Date.parse(o.timestamp)) < Math.abs(v-Date.parse(n.timestamp)) ? o : n) );
            chart2.data.datasets[2].data = selectWhere(closest, "est_available_mah", null, null); 
            chart2.data.datasets[3].data = selectWhere(closest, "est_capacity_mah", null, null); 
            chart2.update();

            var last = closest[closest.length-1];
            var first = closest[0];
            document.getElementById("mahdaily").innerHTML = last.est_available_mah - first.est_available_mah;
        }
        function updateMeterInstant() {
            pollForJsonUpdate(meterInstantTimerID, "powermeter.json", processMeterInstant);
        }
        var meterInstantTimerID = setInterval(updateMeterInstant, 600000); //every 10min, though updated 1/hr, only wait 10min for latest update


        function processAnnualAh(json) {
            if (json == null || !Array.isArray(json)) {
                console.error('Last polled json response had an error.');
                return false;
            }

            //detect change
            json.sort(function (a, b) { if (a == b) return 0; if (a == null) return -1; if (b == null) return 1; var diff = Date.parse(a.date) - Date.parse(b.date); return diff < 0 ? -1 : diff > 0 ? 1 : 0 } );


            //update ChartJs
            chart4.data.labels = selectWhere(json, "date", null, null); 
			chart4.data.datasets[0].data = selectWhere(json, "battery_mah", null, null); 
            chart4.data.datasets[1].data = selectWhere(json, "solar_mah", null, null); 

			var adj = new ymxb(batterysolarcalibration.mN,batterysolarcalibration.mD,24*batterysolarcalibration.b,batterysolarcalibration.n);
			chart4.data.datasets[2].data = Array.from(chart4.data.datasets[0].data, (v,i) => Math.round(adj.y(v)) );
            chart4.update();
        }
        function updateAnnualAh() {
            pollForJsonUpdate(annualAhTimerID, "annualamp.json", processAnnualAh);
        }
        var annualAhTimerID = setInterval(processAnnualAh, 3600000); //every hour, though it only updates 1/day
        
        
		function processNTPperf(json) {
            if (json == null || !Array.isArray(json)) {
                console.error('Last polled json response had an error.');
                return false;
            }

            //detect change

            //update ChartJs
			chart5.data.datasets[0].data = Array.from(json, (v,i)=> v==null ? null : new xy(v.expected_elapsed_rtc_sec, v.actual_elapsed_ntp_sec)); 
			var maxtime = chart5.data.datasets[0].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.max(o,n.x), 0);

			var regression = leastsqrregression(chart5.data.datasets[0].data); 
			chart5.data.datasets[1].data = [regression.f(0), regression.f(maxtime*2)]; 
            
			chart5.data.datasets[1].label = "y = ("+regression.mN+"/"+regression.mD+")x + " + Math.round(regression.b);
			chart5.update();
        }
        function updateNTPperf() {
            pollForJsonUpdate(ntpperfTimerID, "ntp.json", processNTPperf);
        }
        var ntpperfTimerID = 0; //setInterval(processAnnualAh, 60*60*1000); //every hour, though it only updates 1/day

		function localMin(list, start, step){
			if(step==0)
				return null;
			var fall = false;
			start+=step;
			var len = list.length;
			var equals = 0;
			var lastmin;
			while(start>=1 && start<len){
				if(!fall) {
					if(list[start] < list[start-step])
						fall=true;
				} else {
					if(list[start] < list[start+step])
						return list[start];
					else if(equals==0 && list[start] == list[start+step])
						equals = start;
					else if(lastmin != list[start])
						equals = 0;
					lastmin = list[start];
				}
				start+=step;
			}
			return null;
		}
		function localMax(list, start, step){
			if(step==0)
				return null;
			var rise = false;
			start+=step;
			var len = list.length;
			var equals = 0;
			var lastmin;
			while(start>=1 && start<len){
				if(!rise) {
					if(list[start] > list[start-step])
						rise=true;
				} else {
					if(list[start] > list[start+step])
						return list[start];
					else if(equals==0 && list[start] == list[start+step])
						equals = start;
					else if(lastmin != list[start])
						equals = 0;
					lastmin = list[start];
				}
				start+=step;
			}
			return null;
		}
		
		function filterCharge(interval){
			if(interval==null)
				return false;
			return interval.dv>=0 && interval.mA>=0 && interval.mA1>0 && interval.mA2>0;
		}
		function filterDischarge(interval){
			if(interval==null)
				return false;
			return interval.dv<=0 && interval.mA<=0 && interval.mA1<0 && interval.mA2<0 && interval.sma<400;
		}
		function analyzeBatteryHealth() {
			var time = chart1.data.x;
			var ma = chart1.data.datasets[0].data;
			var mv = chart2.data.datasets[0].data;
			var sa = chart1.data.datasets[1].data;

			if(ma==null) return;
			if(mv==null) return;
			if(sa==null) return;

			var intervals = Array.from(time,(v,i)=>i==0 ? null : {ms:(time[i]-time[i-1]), mA1:ma[i], mA2:ma[i-1], mA:(ma[i]+ma[i-1])/2, mAh:(time[i]-time[i-1])*(ma[i]+ma[i-1])/7200000, mv1:mv[i], mv2:mv[i-1], dv:(mv[i]-mv[i-1]), sma:(sa[i]+sa[i-1])/2 });
			//console.log(intervals);
			chart6.data.datasets[0].data = Array.from(intervals.filter(filterDischarge), (v,i)=> v==null ? null : new xy(v.mAh, v.dv)); 
			if(chart6.data.datasets[0].data>1) {
				var discharges = chart6.data.datasets[0].data.length;
				var mintime = chart6.data.datasets[0].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.min(o,n.x), 2200000);
				var regression = leastsqrregression(chart6.data.datasets[0].data.concat(Array(288).fill(new xy(0,0)))); 
				chart6.data.datasets[1].data = [ regression.f(mintime), regression.f(0)]; 
				chart6.data.datasets[1].label = " "+discharges+" * coaxed thru (0,0), y = ("+regression.mN+"/"+regression.mD+")x + " + Math.round(regression.b);
			}
			chart6.data.datasets[2].data = Array.from(intervals.filter(filterCharge), (v,i)=> v==null ? null : new xy(v.mAh, v.dv)); 
			if(chart6.data.datasets[2].data.length>1) {
				var charges = chart6.data.datasets[0].data.length;
				var maxtime = chart6.data.datasets[2].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.max(o,n.x), 0);
				var regression2 = leastsqrregression(chart6.data.datasets[2].data.concat(Array(288).fill(new xy(0,0)))); 
				chart6.data.datasets[3].data = [regression2.f(0), regression2.f(maxtime)]; 
				chart6.data.datasets[3].label = " "+charges+" * coaxed thru (0,0), y = ("+regression2.mN+"/"+regression2.mD+")x + " + Math.round(regression2.b);
			}

			// what I should want is the highest voltage in a charge cycle
			// and lowest voltage in a discharge cycle
			// not the local minimum
			var lowestdischarge = Math.min(...Array.from(intervals.filter(filterDischarge),(v,i)=>v.mv1)); //localMin(mv, mv.length-1, -1);
			var highestcharge = Math.max(...Array.from(intervals.filter(filterCharge),(v,i)=>v.mv1)); //localMax(mv, mv.length-1, -1);
			if(lowestdischarge!=null && regression!=null){
				var until114 = 11400-lowestdischarge;
				var dmah = regression.inv(until114);
				//chart6.data.datasets[1].data.push(dmah);
				chart6.data.datasets[1].label += ", projected " + until114 + "mV/"+Math.round(dmah.x)+"mAh from "+lowestdischarge+"mV until 11.4v";
			}
			if(highestcharge!=null && regression2!=null){
				var until136 = 13600-highestcharge;
				var dmah = regression2.inv(until136);
				//chart6.data.datasets[3].data.push(dmah);
				chart6.data.datasets[3].label += ", projected " + until136 + "mV/"+Math.round(dmah.x)+"mAh from "+highestcharge+"mV until 13.6v";
			}

			chart6.update();
		}
		function checkrtc(json) {
			//if(
			var last = json.reduce((o,n)=>n.created_epoch>o ? n.created_epoch : o, 0);
			var diff = (new Date()).getTime() - last;
			if(last!=0 && diff > 300000) {
				var req = getCancellableXHR();
				if (!req) return false;

				req.onload = function () {
					cancellableXHR = null;
					pollrunning = false;
				};
				req.onerror = function () {
					cancellableXHR = null;
					pollrunning = false;
				};

				var url = "http://192.168.1.200/timesync";
				console.log("Sending GET request thru XHR :" + url);

				req.open('get', url, true);
				req.withCredentials = false;
				req.send(null);
				alert("Got " + last.toString() + ". Difference of " + Math.round(diff/1000) + "sec. Time sync sent to " + url);
			}
		}
		function updateTimeSync() {
            pollForJsonUpdate(ntpperfTimerID, "freememory.json", checkrtc);
        }
        var timesyncTimerID = setInterval(updateTimeSync, 60*1000); //every hour, though it only updates 1/day

		function processCalibration(json) {
            if (json == null || !Array.isArray(json)) {
                console.error('Last polled json response had an error.');
                return false;
            }

            //detect change

            //update ChartJs
			chart7.data.datasets[0].data = Array.from(json, (v,i)=> v==null ? null : new xy(v.diff_mv, v.avg_battery_ma)); 
			var maxah = chart7.data.datasets[0].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.max(o,n.x), 0)+1;
			var minah = chart7.data.datasets[0].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.min(o,n.x), 0)-1;


			//var regression = leastsqrregression(chart7.data.datasets[0].data); 
			var regression = minlinearregression(chart7.data.datasets[0].data); 
			chart7.data.datasets[1].data = [regression.f(minah), regression.f(maxah)]; 
            
			chart7.data.datasets[1].label = "The ammeter reading seems to be (" + Math.round(regression.b) + " mA) of true";
			chart7.update();

			batteryzeroampcalibration = -regression.b;
			batterysolarcalibration.b = -Math.round(batterysolarcalibration.mN*regression.b/batterysolarcalibration.mD);
			displayCalibration();
        }
		function processCalibrationSolarStd() {

			// assume solar ammeter is correct and load is constant thru day
			//need a data of f(battery amps) = solar amps, when solar>500mA for last 24 hours
			var batteryamp  = chart1.data.datasets[0].data;
			var solaramp    = chart1.data.datasets[1].data;
			var batteryvolt = chart2.data.datasets[0].data;
			chart8.data.datasets[0].data = Array.from(batteryamp, (v,i)=> v==null ? null : new xyz(batteryamp[i], solaramp[i], batteryvolt[i])).filter(function(minute) { return minute.y>900;});
			//create regression model of how battery charge sensor reads, to solar sensor and assume solar is correct
			var regression = leastsqrregression(chart8.data.datasets[0].data); 
			//create a line representing the adjustment the battery reading has to make, to be in same calibration as solar sensor
			var maxah = chart8.data.datasets[0].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.max(o,n.x), 0)+1;
			var minah = chart8.data.datasets[0].data.reduce((o,n) => n==null ? o : o==null ? n.x : Math.min(o,n.x), 0)-1;
			chart8.data.datasets[1].data = [regression.f(minah), regression.f(maxah)]; 
            
			chart8.data.datasets[1].label = "The battery ammeter reading seems to be factor of (" + Math.round(10000*regression.mN/regression.mD)/10000 + " mA) of solar";
			chart8.update();

			batteryampcalibration = regression.mN/regression.mD;
			batterysolarcalibration.mN = regression.mN;
			batterysolarcalibration.mD = regression.mD;
			displayCalibration();
        }


        function startup(json) {
            processIntervalAvg(json);
			pollForJsonUpdate(intervalAvgTimerID, "houravg.json", startup2);
        }
        function startup2(json) {
            processHourlyAh(json);
			//... add next in the chain
            //updateMeterInstant();
			pollForJsonUpdate(intervalAvgTimerID, "powermeter.json", startup3);
        }
		function startup3(json) {
            processMeterInstant(json);
			//... add next in the chain
			pollForJsonUpdate(annualAhTimerID, "annualamp.json", startup4);
        }
		function startup4(json) {
            processAnnualAh(json);
			//... add next in the chain
            //updateNTPperf();
			pollForJsonUpdate(ntpperfTimerID, "ntp.json", startup5);
        }
		function startup5(json) {
            processNTPperf(json);
			//... add next in the chain
			pollForJsonUpdate(0, "ammetercalibration.json", processCalibration);
        }
        pollForJsonUpdate(intervalAvgTimerID, "latestintervalavgs.json", startup);
        

	</script>
</body>
</html>
